# 6. MIGRATIONS_REASONING_PROTOCOL.md

> Protocolo obligatorio para razonar, diseñar y ejecutar migraciones seguras en FluxCore.
>
> **Estado base verificado:**
> - Base viva: `docker exec fluxcore-db psql -U postgres -d fluxcore -c "\dt"` → 63 tablas reales en `public`.
> - Tabla `fluxcore_template_settings` confirmada (nueva tabla de extensión).
> - Tabla `templates` limpia de columnas de IA (`authorize_for_ai` eliminada).
> - Registro de migraciones Drizzle incompleto (se priorizan scripts manuales).

> **Precondición global:** Antes de proponer, diseñar o ejecutar cualquier migración, la IA debe citar explícitamente este archivo y declarar que completó todos los pasos del protocolo. Si no puede aportar evidencia para algún punto, debe detenerse y escalar.

## Evidencia persistente (actualizar en cada sesión)

- **Última verificación completa:** 2026-02-10 07:30 (UTC-03) · Fase 3 Agent Runtime Engine · contenedor `fluxcore-db`.
- **Comandos ejecutados:**
  1. `docker-compose up -d postgres redis` → servicios `fluxcore-db` y `fluxcore-redis` levantados.
  2. `\dt public.*` → 61 tablas antes de migración; confirmó ausencia de `fluxcore_agents` y `fluxcore_agent_assistants`.
  3. `DATABASE_URL=... bun run src/migrate-agents.ts` → Creación exitosa de ambas tablas.
  4. `\d+ fluxcore_agents` / `\d+ fluxcore_agent_assistants` → Estructura, índices y FKs verificados.
  5. Conteo post-migración: **63 tablas** en `public`.
- **Hallazgos vigentes:**
  - La tabla `templates` es PURA (propiedad del Chat Core).
  - La tabla `fluxcore_template_settings` gestiona la extensión de IA (`authorize_for_ai`, `ai_usage_instructions`).
  - El código backend orquesta la lectura/escritura transparente.
  - Tablas `ai_traces`, `ai_signals`, `ai_suggestions` ya aplicadas en DB viva.
  - Tablas `fluxcore_agents` y `fluxcore_agent_assistants` creadas (Fase 3 Agent Runtime Engine).
- **Cambios registrados manualmente:**
  - **2026-02-05:** Añadida columna `authorize_for_ai` a la tabla `templates` mediante script `033_template_ai_authorization.sql`. (DEPRECADA Y MIGRADA).
  - **2026-02-06:** Refactorización Arquitectónica (`034_fluxcore_template_refactor.sql`). Se movió `authorize_for_ai` a `fluxcore_template_settings` y se agregó `ai_usage_instructions`.
  - **2026-02-09:** AI Persistence (`035_ai_persistence.sql`). Tres nuevas tablas: `ai_traces` (ejecuciones IA), `ai_signals` (señales internas del LLM), `ai_suggestions` (suggestions persistidas). Aplicada.
  - **2026-02-10:** Agent Runtime Engine (`migrate-agents.ts`). Dos nuevas tablas: `fluxcore_agents` (definición de agentes con flow/scopes/trigger), `fluxcore_agent_assistants` (N:M agente↔asistente con rol y step_id). FKs a `accounts` y `fluxcore_assistants` con CASCADE. Aplicada.
  - **2026-02-13:** Runtime Sovereignty (`account-runtime-config.ts`). Nueva tabla: `account_runtime_config` para centralizar qué cerebro (WES/@fluxcore/wes o Agentes/@fluxcore/fluxcore) es el responsable oficial de una cuenta. Separación clara entre *Runtime* (Quién piensa) y *Automation Rules* (Modo de respuesta).

Objetivo: reaprovechar evidencia fresca para no repetir siempre las mismas consultas. Si el entorno cambió o la información está desactualizada, se debe re-ejecutar la verificación completa y actualizar este bloque antes de seguir.

## Regla 0 · Cuestionario obligatorio

Ninguna migración se diseña ni ejecuta hasta que este asistente responda **todas** las preguntas del “Razonamiento guiado” (sección siguiente) con evidencias frescas. Si alguna respuesta queda en "desconocido", la migración no avanza.

## Gate operacional

La migración **no se ejecuta** si este asistente no puede cruzar simultáneamente:
1. **DB viva** (`psql` sobre `fluxcore-db`).
2. **Schema ORM** (`packages/db/src/schema`).
3. **Journal de migraciones** (`drizzle.__drizzle_migrations`).

Si alguno de los tres diverge o falta, la tarea queda bloqueada hasta resolverlo.

## Razonamiento guiado (paso a paso)

1. **Estado real del sistema**
   1. Fuente de verdad actual del esquema (¿DB, ORM, migraciones?)
   2. Tablas reales existentes (número, ausentes/presentes en ORM, origen manual)
   3. Tablas con datos críticos o sensibles (usuarios, cuentas, jobs, logs, históricos)
   4. Tablas huérfanas/legacy (¿cómo se sabe?, ¿aún referenciadas?)
2. **Historia y confiabilidad**
   5. Tabla de control de migraciones (nombre, qué registra, si es confiable)
   6. Migraciones nunca aplicadas / parciales / modificadas
   7. Si el orden del journal refleja el orden real o hubo hotfixes
   8. Nivel de confianza entre código, migraciones y DB (justificado)
3. **Riesgos reales**
   9. Peor escenario de una migración incorrecta (pérdida de datos, bloqueo, corrupción)
   10. Capacidad real de rollback (automático, manual, inexistente)
   11. Tablas intocables sin plan explícito
4. **Tipo de cambio**
   12. Naturaleza del cambio (estructural, semántico, operativo, correctivo)
   13. Si afecta datos existentes o solo futuros
   14. Capacidad del sistema para convivir con dobles versiones/flags
5. **Estrategia previa**
   15. Necesidad de fases, backfill o scripts auxiliares
   16. Validaciones previas (conteos, constraints, valores inválidos)
   17. Validaciones posteriores (checksums, conteos comparativos, queries de integridad)
6. **ORM ↔ Base**
   18. Si el ORM puede representar fielmente el cambio
   19. Determinismo de las migraciones generadas y riesgos asociados
   20. Partes que no deben delegarse al ORM
7. **Entornos y ejecución**
   21. Estrategia de pruebas (base limpia, copia real, etc.)
   22. Naturaleza de la migración (repetible, idempotente, sensible al estado)
   23. Señales rojas para no ejecutar en producción
8. **Decisiones explícitas**
   24. Qué se toca, qué no y qué se posterga
   25. Deuda técnica aceptada conscientemente
9. **Reglas futuras**
   26. Normas resultantes para migraciones venideras, prohibiciones y revisiones humanas
10. **Síntesis final**
   27. Decálogo operativo específico para FluxCore (basado solo en hechos verificados)

## Decálogo operativo vigente

1. **Confirmar la estructura real en la DB viva antes de tocarla**, usando `psql` (`\dt`, `\d+ tabla`, conteos). El journal sólo contiene 4 entradas, por lo que no garantiza el estado completo.
2. **Tomar snapshot manual (pg_dump u otro backup) de tablas críticas** (`users`, `accounts`, `messages`, `account_deletion_jobs/logs`, `credits_*`, `fluxcore_*`) antes de cualquier alteración: no existe rollback automático.
3. **Actualizar el schema Drizzle en paralelo** (`packages/db/src/schema`) cada vez que se confirme un cambio real en la DB para que `@fluxcore/db` siga reflejando la verdad usada en runtime.
4. **Ejecutar validaciones antes y después** (conteos, `IS NULL`, verificación de índices) para detectar inconsistencias inmediatas.
5. **Registrar toda migración manual** (script, fecha, propósito). Los cambios fuera de Drizzle deben quedar trazados porque `drizzle.__drizzle_migrations` no los conserva.
6. **No eliminar ni renombrar columnas usadas en código activo** (p. ej. `account_deletion_jobs.status`, `metadata`, `phase`) sin actualizar simultáneamente a todos los consumidores.
7. **Preferir migraciones idempotentes** (`CREATE ... IF NOT EXISTS`, `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`) para tolerar re-ejecuciones en entornos ya tocados.
8. **Planificar migraciones en fases** cuando haya datos existentes: incluye scripts de backfill, flags temporales o ventanas coordinadas si el sistema no soporta doble esquema.
9. **Revisar el SQL generado por Drizzle** antes de aplicarlo; índices condicionales, columnas `jsonb` o tipos especiales (`vector`) no deben delegarse ciegamente.
10. **No ejecutar en producción si las validaciones previas fallan o si falta evidencia completa (DB + schema + journal)**; la tarea queda bloqueada hasta reunir las tres fuentes.

## Referencias cruzadas
- Schema ORM: `packages/db/src/schema/` (todas las tablas exportadas via `index.ts`).
- Uso en runtime (ejemplo clave): `apps/api/src/workers/account-deletion.processor.ts` depende de `account_deletion_jobs` y `account_deletion_logs`.
- DB viva: contenedores `fluxcore-db` y `fluxcore-redis` levantados mediante `docker-compose up -d postgres redis`.

> Siempre documentar en este archivo cualquier ajuste futuro al protocolo (fecha + motivo).
