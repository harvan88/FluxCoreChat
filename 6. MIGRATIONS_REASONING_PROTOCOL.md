# 6. MIGRATIONS_REASONING_PROTOCOL.md

> Protocolo obligatorio para razonar, diseñar y ejecutar migraciones seguras en FluxCore.
>
> **Estado base verificado:**
> - Base viva: `docker exec fluxcore-db psql -U postgres -d fluxcore -c "\\dt"` → 56 tablas reales en `public`.
> - Tabla `account_deletion_jobs` confirmada con `\d+` (defaults, índices y FKs vigentes).
> - Registro de migraciones Drizzle (`drizzle.__drizzle_migrations`) muestra solo 4 entradas → el journal es incompleto.

> **Precondición global:** Antes de proponer, diseñar o ejecutar cualquier migración, la IA debe citar explícitamente este archivo y declarar que completó todos los pasos del protocolo. Si no puede aportar evidencia para algún punto, debe detenerse y escalar.

## Evidencia persistente (actualizar en cada sesión)

- **Última verificación completa:** 2026-02-05 14:00 (UTC-03) · Cascade · contenedor `fluxcore-db` levantado vía `docker-compose up -d postgres redis`.
- **Comandos ejecutados:**
  1. `docker-compose ps` → confirmó servicios `fluxcore-db` y `fluxcore-redis` healthy.
  2. `docker exec fluxcore-db psql -U postgres -d fluxcore -c "\dt"` → listó 56 tablas actuales en `public`.
  3. `docker exec fluxcore-db psql -U postgres -d fluxcore -c "SELECT column_name FROM information_schema.columns WHERE table_name = 'templates';"` → verificó columnas de `templates`, incluyendo la nueva `authorize_for_ai`.
  4. `docker exec fluxcore-db psql -U postgres -d fluxcore -c "SELECT * FROM drizzle.__drizzle_migrations;"` → journal contiene solo 4 entradas (id 1-4) → incompleto.
- **Hallazgos vigentes:**
  - Todas las tablas listadas en `packages/db/src/schema/index.ts` aparecen en la DB real (56 tablas).
  - La tabla `templates` ahora cuenta con la columna `authorize_for_ai` (boolean, default false).
  - Journal de Drizzle no refleja scripts manuales; cualquier cambio adicional debe documentarse aquí.
- **Cambios registrados manualmente:**
  - **2026-02-05:** Añadida columna `authorize_for_ai` a la tabla `templates` mediante script `033_template_ai_authorization.sql`. Idempotente.

Objetivo: reaprovechar evidencia fresca para no repetir siempre las mismas consultas. Si el entorno cambió o la información está desactualizada, se debe re-ejecutar la verificación completa y actualizar este bloque antes de seguir.

## Regla 0 · Cuestionario obligatorio

Ninguna migración se diseña ni ejecuta hasta que este asistente responda **todas** las preguntas del “Razonamiento guiado” (sección siguiente) con evidencias frescas. Si alguna respuesta queda en "desconocido", la migración no avanza.

## Gate operacional

La migración **no se ejecuta** si este asistente no puede cruzar simultáneamente:
1. **DB viva** (`psql` sobre `fluxcore-db`).
2. **Schema ORM** (`packages/db/src/schema`).
3. **Journal de migraciones** (`drizzle.__drizzle_migrations`).

Si alguno de los tres diverge o falta, la tarea queda bloqueada hasta resolverlo.

## Razonamiento guiado (paso a paso)

1. **Estado real del sistema**
   1. Fuente de verdad actual del esquema (¿DB, ORM, migraciones?)
   2. Tablas reales existentes (número, ausentes/presentes en ORM, origen manual)
   3. Tablas con datos críticos o sensibles (usuarios, cuentas, jobs, logs, históricos)
   4. Tablas huérfanas/legacy (¿cómo se sabe?, ¿aún referenciadas?)
2. **Historia y confiabilidad**
   5. Tabla de control de migraciones (nombre, qué registra, si es confiable)
   6. Migraciones nunca aplicadas / parciales / modificadas
   7. Si el orden del journal refleja el orden real o hubo hotfixes
   8. Nivel de confianza entre código, migraciones y DB (justificado)
3. **Riesgos reales**
   9. Peor escenario de una migración incorrecta (pérdida de datos, bloqueo, corrupción)
   10. Capacidad real de rollback (automático, manual, inexistente)
   11. Tablas intocables sin plan explícito
4. **Tipo de cambio**
   12. Naturaleza del cambio (estructural, semántico, operativo, correctivo)
   13. Si afecta datos existentes o solo futuros
   14. Capacidad del sistema para convivir con dobles versiones/flags
5. **Estrategia previa**
   15. Necesidad de fases, backfill o scripts auxiliares
   16. Validaciones previas (conteos, constraints, valores inválidos)
   17. Validaciones posteriores (checksums, conteos comparativos, queries de integridad)
6. **ORM ↔ Base**
   18. Si el ORM puede representar fielmente el cambio
   19. Determinismo de las migraciones generadas y riesgos asociados
   20. Partes que no deben delegarse al ORM
7. **Entornos y ejecución**
   21. Estrategia de pruebas (base limpia, copia real, etc.)
   22. Naturaleza de la migración (repetible, idempotente, sensible al estado)
   23. Señales rojas para no ejecutar en producción
8. **Decisiones explícitas**
   24. Qué se toca, qué no y qué se posterga
   25. Deuda técnica aceptada conscientemente
9. **Reglas futuras**
   26. Normas resultantes para migraciones venideras, prohibiciones y revisiones humanas
10. **Síntesis final**
   27. Decálogo operativo específico para FluxCore (basado solo en hechos verificados)

## Decálogo operativo vigente

1. **Confirmar la estructura real en la DB viva antes de tocarla**, usando `psql` (`\dt`, `\d+ tabla`, conteos). El journal sólo contiene 4 entradas, por lo que no garantiza el estado completo.
2. **Tomar snapshot manual (pg_dump u otro backup) de tablas críticas** (`users`, `accounts`, `messages`, `account_deletion_jobs/logs`, `credits_*`, `fluxcore_*`) antes de cualquier alteración: no existe rollback automático.
3. **Actualizar el schema Drizzle en paralelo** (`packages/db/src/schema`) cada vez que se confirme un cambio real en la DB para que `@fluxcore/db` siga reflejando la verdad usada en runtime.
4. **Ejecutar validaciones antes y después** (conteos, `IS NULL`, verificación de índices) para detectar inconsistencias inmediatas.
5. **Registrar toda migración manual** (script, fecha, propósito). Los cambios fuera de Drizzle deben quedar trazados porque `drizzle.__drizzle_migrations` no los conserva.
6. **No eliminar ni renombrar columnas usadas en código activo** (p. ej. `account_deletion_jobs.status`, `metadata`, `phase`) sin actualizar simultáneamente a todos los consumidores.
7. **Preferir migraciones idempotentes** (`CREATE ... IF NOT EXISTS`, `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`) para tolerar re-ejecuciones en entornos ya tocados.
8. **Planificar migraciones en fases** cuando haya datos existentes: incluye scripts de backfill, flags temporales o ventanas coordinadas si el sistema no soporta doble esquema.
9. **Revisar el SQL generado por Drizzle** antes de aplicarlo; índices condicionales, columnas `jsonb` o tipos especiales (`vector`) no deben delegarse ciegamente.
10. **No ejecutar en producción si las validaciones previas fallan o si falta evidencia completa (DB + schema + journal)**; la tarea queda bloqueada hasta reunir las tres fuentes.

## Referencias cruzadas
- Schema ORM: `packages/db/src/schema/` (todas las tablas exportadas via `index.ts`).
- Uso en runtime (ejemplo clave): `apps/api/src/workers/account-deletion.processor.ts` depende de `account_deletion_jobs` y `account_deletion_logs`.
- DB viva: contenedores `fluxcore-db` y `fluxcore-redis` levantados mediante `docker-compose up -d postgres redis`.

> Siempre documentar en este archivo cualquier ajuste futuro al protocolo (fecha + motivo).
