/**
 * Cleanup Script: Remove test data generated by automated runs
 *
 * Deletes users whose email starts with test prefixes and relies on
 * cascading FK constraints to remove related accounts, actors, conversations, etc.
 */

import { db } from './connection';
import {
  users,
  accounts,
  actors,
  messages,
  relationships,
  conversations,
  workspaceInvitations,
  workspaceMembers,
  extensionInstallations,
} from './schema';
import { like, or, sql, inArray } from 'drizzle-orm';

const TEST_PATTERNS = [
  { label: 'test%', pattern: 'test%' },
  { label: 'wsmember%', pattern: 'wsmember%' },
  { label: 'wsowner%', pattern: 'wsowner%' },
  { label: 'exttest%', pattern: 'exttest%' },
];

async function countUsers(pattern?: string) {
  if (pattern) {
    const [result] = await db
      .select({ total: sql<number>`count(*)` })
      .from(users)
      .where(like(users.email, pattern));
    return Number(result.total);
  }

  const [result] = await db.select({ total: sql<number>`count(*)` }).from(users);
  return Number(result.total);
}

async function main() {
  console.log('üßπ Eliminando datos de prueba...\n');

  // Count before
  const beforeTotals = await Promise.all(
    TEST_PATTERNS.map(async ({ label, pattern }) => ({
      label,
      count: await countUsers(pattern),
    }))
  );
  const testCondition = or(...TEST_PATTERNS.map(({ pattern }) => like(users.email, pattern)));

  const totalUsersBefore = await countUsers();
  const testUsersBefore = beforeTotals.reduce((acc, item) => acc + item.count, 0);
  const realUsersBefore = totalUsersBefore - testUsersBefore;

  console.table(beforeTotals);
  console.log(`Usuarios reales: ${realUsersBefore}\n`);

  // Gather test user IDs
  const testUsers = await db.select({ id: users.id, email: users.email }).from(users).where(testCondition);
  const testUserIds = testUsers.map((u) => u.id);

  if (testUserIds.length === 0) {
    console.log('No hay usuarios de prueba para eliminar.');
    return;
  }

  // Derive account + relationship IDs for those users
  const testAccounts = await db
    .select({ id: accounts.id })
    .from(accounts)
    .where(inArray(accounts.ownerUserId, testUserIds));
  const testAccountIds = testAccounts.map((a) => a.id);

  const testRelationships = await db
    .select({ id: relationships.id })
    .from(relationships)
    .where(
      or(
        inArray(relationships.accountAId, testAccountIds),
        inArray(relationships.accountBId, testAccountIds)
      )
    );
  const testRelationshipIds = testRelationships.map((r) => r.id);

  const testConversationIds =
    testRelationshipIds.length > 0
      ? (
          await db
            .select({ id: conversations.id })
            .from(conversations)
            .where(inArray(conversations.relationshipId, testRelationshipIds))
        ).map((c) => c.id)
      : [];

  // Delete dependent records referencing users directly
  if (testUserIds.length > 0) {
    await db.delete(workspaceInvitations).where(inArray(workspaceInvitations.invitedBy, testUserIds));
    await db.delete(workspaceMembers).where(inArray(workspaceMembers.userId, testUserIds));
  }

  if (testAccountIds.length > 0) {
    await db.delete(messages).where(inArray(messages.senderAccountId, testAccountIds));
    await db.delete(extensionInstallations).where(inArray(extensionInstallations.accountId, testAccountIds));
    await db.delete(actors).where(inArray(actors.accountId, testAccountIds));
  }

  if (testConversationIds.length > 0) {
    await db.delete(conversations).where(inArray(conversations.id, testConversationIds));
  }

  if (testRelationshipIds.length > 0) {
    await db.delete(relationships).where(inArray(relationships.id, testRelationshipIds));
  }

  // Delete test users (cascade removes accounts, actors, etc.)
  const deleted = await db
    .delete(users)
    .where(inArray(users.id, testUserIds))
    .returning({ id: users.id, email: users.email });

  console.log(`üóëÔ∏è  Eliminados ${deleted.length} usuarios de prueba.`);

  // Counts after
  const afterTotals = await Promise.all(
    TEST_PATTERNS.map(async ({ label, pattern }) => ({
      label,
      count: await countUsers(pattern),
    }))
  );
  const remainingUsers = await countUsers();

  console.log('\nEstado final:');
  console.table(afterTotals);
  console.log(`Usuarios totales restantes: ${remainingUsers}`);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('‚ùå Error limpiando datos de prueba:', error);
    process.exit(1);
  });
