import { messageService } from '../services/message.service';
import { conversationService } from '../services/conversation.service';
import { relationshipService } from '../services/relationship.service';
import { extensionHost, type ProcessMessageResult } from '../services/extension-host.service';
import { automationController, type TriggerEvaluation } from '../services/automation-controller.service';

import { coreEventBus } from './events';
import type { MessageEnvelope, ReceiveResult } from './types';

export { MessageEnvelope, ReceiveResult }; // Re-export para compatibilidad (opcional)

/**
 * MessageCore - El corazón del sistema de mensajería
 * 
 * Responsabilidades:
 * 1. Recibir mensajes de cualquier fuente (adapter, UI)
 * 2. Persistir inmediatamente
 * 3. Notificar via WebSocket (delegado a NotificationService)
 * 4. Actualizar metadatos de conversación
 * 5. Actualizar última interacción en relationship
 * 6. DELEGAR a ExtensionHost para procesamiento de extensiones (COR-001)
 * 
 * NO hace:
 * - Lógica de IA (eso es de extensiones)
 * - Orquestación compleja (eso es de extensiones)
 * - Validación de permisos (eso es middleware)
 */
export class MessageCore {
  private notificationCallbacks: Map<string, (data: any) => void> = new Map();
  // R-02.3: autoReplyQueue movida a AIOrchestrator
  private conversations = new Map<string, { relationshipId: string }>();
  private rooms: Map<string, any[]> = new Map();

  /**
   * Recibe y procesa un mensaje
   * COR-001: Ahora delega a ExtensionHost para que las extensiones procesen el mensaje
   */
  async receive(envelope: MessageEnvelope): Promise<ReceiveResult> {
    try {
      // 1. Persistir mensaje
      const message = await messageService.createMessage({
        conversationId: envelope.conversationId,
        senderAccountId: envelope.senderAccountId,
        content: envelope.content,
        type: envelope.type,
        generatedBy: envelope.generatedBy || 'human',
      });

      // 2. Actualizar conversación y obtener datos
      const conversation = await conversationService.getConversationById(envelope.conversationId);
      let extensionResults: ProcessMessageResult[] = [];
      let automationResult: TriggerEvaluation | undefined;

      if (conversation) {
        const messageText = typeof envelope.content?.text === 'string' ? envelope.content.text : '';
        await conversationService.updateConversation(envelope.conversationId, {
          lastMessageAt: new Date(),
          lastMessageText: messageText.substring(0, 500),
        });

        // 3. Actualizar última interacción en relationship
        await relationshipService.updateLastInteraction(conversation.relationshipId);

        // 4. Notificar via WebSocket
        this.broadcast(conversation.relationshipId, {
          type: 'message:new',
          data: {
            ...message,
            conversationId: envelope.conversationId,
            senderAccountId: envelope.senderAccountId,
            content: envelope.content,
          },
        });

        // 5. DELEGAR A EXTENSIONHOST (COR-001)
        // Determinar el accountId target para las extensiones
        const relationship = await relationshipService.getRelationshipById(conversation.relationshipId);

        if (relationship) {
          // El targetAccountId es la cuenta que RECIBE el mensaje (no el sender)
          const targetAccountId = envelope.targetAccountId ||
            (envelope.senderAccountId === relationship.accountAId
              ? relationship.accountBId
              : relationship.accountAId);

          // Asegurar que el envelope tenga el target para consumidores downstream (EventBus)
          envelope.targetAccountId = targetAccountId;

          if (envelope.generatedBy === 'ai') {
            automationResult = {
              shouldProcess: false,
              mode: 'disabled',
              rule: null,
              reason: 'Message generated by AI, skipping automation',
            };
          } else {
            const messageTypeForTarget: 'incoming' | 'outgoing' | 'system' =
              envelope.senderAccountId === targetAccountId ? 'outgoing' : 'incoming';

            automationResult = await automationController.evaluateTrigger({
              accountId: targetAccountId,
              relationshipId: conversation.relationshipId,
              messageContent: messageText,
              messageType: messageTypeForTarget,
              senderId: envelope.senderAccountId,
            });
          }

          // Solo procesar con extensiones si automation lo permite
          if (automationResult.shouldProcess) {
            // Procesar mensaje con extensiones del target
            extensionResults = await extensionHost.processMessage({
              accountId: targetAccountId,
              relationshipId: conversation.relationshipId,
              conversationId: envelope.conversationId,
              message: {
                id: message.id,
                content: envelope.content,
                type: envelope.type,
                senderAccountId: envelope.senderAccountId,
              },
              // COR-007: Pasar modo de automatización a extensiones
              automationMode: automationResult.mode,
            });

            // R-02.2: Lógica de respuesta automática movida a AIOrchestrator (via eventos)
          } else {
            // Notificar que automation está deshabilitado
            console.log(`[MessageCore] Automation disabled for ${targetAccountId}: ${automationResult.reason}`);
          }
        }
      }

      const result: ReceiveResult = {
        success: true,
        messageId: message.id,
        extensionResults,
        automation: automationResult,
      };

      // R-02.1: Emitir evento para desacoplar lógica (IA, Analytics)
      coreEventBus.emit('core:message_received', { envelope, result });

      return result;
    } catch (error: any) {
      console.error('MessageCore.receive error:', error);
      return {
        success: false,
        error: error.message || 'Failed to receive message',
      };
    }
  }

  /**
   * Envía un mensaje (alias de receive para consistencia de API)
   */
  async send(envelope: MessageEnvelope): Promise<ReceiveResult> {
    return this.receive(envelope);
  }

  /**
   * Obtiene el historial de mensajes de una conversación
   */
  async getHistory(conversationId: string, limit = 50, offset = 0) {
    return await messageService.getMessagesByConversationId(conversationId, limit, offset);
  }

  /**
   * Registra un callback para notificaciones
   */
  subscribe(relationshipId: string, callback: (data: any) => void) {
    this.notificationCallbacks.set(relationshipId, callback);
  }

  /**
   * Desregistra un callback
   */
  unsubscribe(relationshipId: string) {
    this.notificationCallbacks.delete(relationshipId);
  }

  /**
   * Broadcast a todos los subscriptores de una relación
   */
  private broadcast(relationshipId: string, data: any) {
    const callback = this.notificationCallbacks.get(relationshipId);
    if (callback) {
      callback(data);
    }
  }

  registerConversation(conversationId: string, relationshipId: string) {
    this.conversations.set(conversationId, { relationshipId });
    console.log(`[MessageCore] Registered conversation ${conversationId} with relationship ${relationshipId}`);
  }

  /**
   * Transmite estado de actividad a participantes
   */
  broadcastActivity(conversationId: string, payload: any) {
    const conv = this.conversations.get(conversationId);
    if (conv) {
      this.broadcast(conv.relationshipId, {
        type: 'user_activity_state',
        ...payload,
        conversationId
      });
    } else {
      // Fallback: Broadcast to all connections in the conversation room
      console.warn(`[WARN] Broadcasting activity without registration for conversation ${conversationId}`);
      this.broadcastToRoom(conversationId, {
        type: 'user_activity_state',
        ...payload,
        conversationId
      });
    }
  }

  private broadcastToRoom(roomId: string, message: any) {
    const connections = this.rooms.get(roomId) || [];
    connections.forEach(conn => {
      conn.send(JSON.stringify(message));
    });
  }
}

export const messageCore = new MessageCore();
