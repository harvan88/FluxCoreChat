import { messageService } from '../services/message.service';
import { conversationService } from '../services/conversation.service';
import { relationshipService } from '../services/relationship.service';
import { extensionHost, type ProcessMessageResult } from '../services/extension-host.service';
import { automationController, type TriggerEvaluation } from '../services/automation-controller.service';
import type { MessageContent } from '@fluxcore/db';

export interface MessageEnvelope {
  id?: string;
  conversationId: string;
  senderAccountId: string;
  content: MessageContent;
  type: 'incoming' | 'outgoing' | 'system';
  generatedBy?: 'human' | 'ai';
  timestamp?: Date;
  // Contexto adicional para extensiones
  targetAccountId?: string;  // La cuenta que recibe el mensaje (para extensiones)
}

export interface ReceiveResult {
  success: boolean;
  messageId?: string;
  error?: string;
  // Resultados del procesamiento de extensiones
  extensionResults?: ProcessMessageResult[];
  // COR-007: Información de automatización
  automation?: TriggerEvaluation;
}

/**
 * MessageCore - El corazón del sistema de mensajería
 * 
 * Responsabilidades:
 * 1. Recibir mensajes de cualquier fuente (adapter, UI)
 * 2. Persistir inmediatamente
 * 3. Notificar via WebSocket (delegado a NotificationService)
 * 4. Actualizar metadatos de conversación
 * 5. Actualizar última interacción en relationship
 * 6. DELEGAR a ExtensionHost para procesamiento de extensiones (COR-001)
 * 
 * NO hace:
 * - Lógica de IA (eso es de extensiones)
 * - Orquestación compleja (eso es de extensiones)
 * - Validación de permisos (eso es middleware)
 */
export class MessageCore {
  private notificationCallbacks: Map<string, (data: any) => void> = new Map();
  private autoReplyQueue: Map<string, ReturnType<typeof setTimeout>> = new Map();
  private conversations = new Map<string, { relationshipId: string }>();
  private rooms: Map<string, any[]> = new Map();

  /**
   * Recibe y procesa un mensaje
   * COR-001: Ahora delega a ExtensionHost para que las extensiones procesen el mensaje
   */
  async receive(envelope: MessageEnvelope): Promise<ReceiveResult> {
    try {
      // 1. Persistir mensaje
      const message = await messageService.createMessage({
        conversationId: envelope.conversationId,
        senderAccountId: envelope.senderAccountId,
        content: envelope.content,
        type: envelope.type,
        generatedBy: envelope.generatedBy || 'human',
      });

      // 2. Actualizar conversación y obtener datos
      const conversation = await conversationService.getConversationById(envelope.conversationId);
      let extensionResults: ProcessMessageResult[] = [];
      let automationResult: TriggerEvaluation | undefined;

      if (conversation) {
        const messageText = typeof envelope.content?.text === 'string' ? envelope.content.text : '';
        await conversationService.updateConversation(envelope.conversationId, {
          lastMessageAt: new Date(),
          lastMessageText: messageText.substring(0, 500),
        });

        // 3. Actualizar última interacción en relationship
        await relationshipService.updateLastInteraction(conversation.relationshipId);

        // 4. Notificar via WebSocket
        this.broadcast(conversation.relationshipId, {
          type: 'message:new',
          data: {
            ...message,
            conversationId: envelope.conversationId,
            senderAccountId: envelope.senderAccountId,
            content: envelope.content,
          },
        });

        // 5. DELEGAR A EXTENSIONHOST (COR-001)
        // Determinar el accountId target para las extensiones
        const relationship = await relationshipService.getRelationshipById(conversation.relationshipId);

        if (relationship) {
          // El targetAccountId es la cuenta que RECIBE el mensaje (no el sender)
          const targetAccountId = envelope.targetAccountId || 
            (envelope.senderAccountId === relationship.accountAId 
              ? relationship.accountBId 
              : relationship.accountAId);

          if (envelope.generatedBy === 'ai') {
            automationResult = {
              shouldProcess: false,
              mode: 'disabled',
              rule: null,
              reason: 'Message generated by AI, skipping automation',
            };
          } else {
            const messageTypeForTarget: 'incoming' | 'outgoing' | 'system' =
              envelope.senderAccountId === targetAccountId ? 'outgoing' : 'incoming';

            automationResult = await automationController.evaluateTrigger({
              accountId: targetAccountId,
              relationshipId: conversation.relationshipId,
              messageContent: messageText,
              messageType: messageTypeForTarget,
              senderId: envelope.senderAccountId,
            });
          }

          // Solo procesar con extensiones si automation lo permite
          if (automationResult.shouldProcess) {
            // Procesar mensaje con extensiones del target
            extensionResults = await extensionHost.processMessage({
              accountId: targetAccountId,
              relationshipId: conversation.relationshipId,
              conversationId: envelope.conversationId,
              message: {
                id: message.id,
                content: envelope.content,
                type: envelope.type,
                senderAccountId: envelope.senderAccountId,
              },
              // COR-007: Pasar modo de automatización a extensiones
              automationMode: automationResult.mode,
            });

            if (
              automationResult.mode === 'automatic' &&
              typeof messageText === 'string' &&
              messageText.trim().length > 0
            ) {
              const debounceKey = envelope.conversationId;
              const existingTimeout = this.autoReplyQueue.get(debounceKey);
              if (existingTimeout) {
                clearTimeout(existingTimeout);
                this.autoReplyQueue.delete(debounceKey);
              }

              // Mapeo de modo de automatización a modo de IA
              const aiMode = automationResult.mode === 'automatic' ? 'auto' : 'suggest';

              const delayMs = await extensionHost.getAIAutoReplyDelayMs(targetAccountId);

              const timeout = setTimeout(async () => {
                try {
                  const suggestion = await extensionHost.generateAIResponse(
                    envelope.conversationId,
                    targetAccountId,
                    messageText,
                    {
                      mode: aiMode,
                      triggerMessageId: message.id,
                      triggerMessageCreatedAt: (message as any).createdAt,
                      traceId: message.id,
                    }
                  );

                  if (suggestion?.content) {
                    const stripped = extensionHost.stripFluxCorePromoMarker(suggestion.content);
                    const finalText = stripped.promo
                      ? extensionHost.appendFluxCoreBrandingFooter(stripped.text)
                      : stripped.text;

                    const content: any = stripped.promo
                      ? { text: finalText, __fluxcore: { branding: true } }
                      : { text: finalText };

                    await this.send({
                      conversationId: envelope.conversationId,
                      senderAccountId: targetAccountId,
                      content,
                      type: 'outgoing',
                      generatedBy: 'ai',
                    });
                  }
                } finally {
                  this.autoReplyQueue.delete(debounceKey);
                }
              }, delayMs);

              this.autoReplyQueue.set(debounceKey, timeout);
            }
          } else {
            // Notificar que automation está deshabilitado
            console.log(`[MessageCore] Automation disabled for ${targetAccountId}: ${automationResult.reason}`);
          }
        }
      }

      return {
        success: true,
        messageId: message.id,
        extensionResults,
        automation: automationResult,
      };
    } catch (error: any) {
      console.error('MessageCore.receive error:', error);
      return {
        success: false,
        error: error.message || 'Failed to receive message',
      };
    }
  }

  /**
   * Envía un mensaje (alias de receive para consistencia de API)
   */
  async send(envelope: MessageEnvelope): Promise<ReceiveResult> {
    return this.receive(envelope);
  }

  /**
   * Obtiene el historial de mensajes de una conversación
   */
  async getHistory(conversationId: string, limit = 50, offset = 0) {
    return await messageService.getMessagesByConversationId(conversationId, limit, offset);
  }

  /**
   * Registra un callback para notificaciones
   */
  subscribe(relationshipId: string, callback: (data: any) => void) {
    this.notificationCallbacks.set(relationshipId, callback);
  }

  /**
   * Desregistra un callback
   */
  unsubscribe(relationshipId: string) {
    this.notificationCallbacks.delete(relationshipId);
  }

  /**
   * Broadcast a todos los subscriptores de una relación
   */
  private broadcast(relationshipId: string, data: any) {
    const callback = this.notificationCallbacks.get(relationshipId);
    if (callback) {
      callback(data);
    }
  }

  registerConversation(conversationId: string, relationshipId: string) {
    this.conversations.set(conversationId, { relationshipId });
    console.log(`[MessageCore] Registered conversation ${conversationId} with relationship ${relationshipId}`);
  }

  /**
   * Transmite estado de actividad a participantes
   */
  broadcastActivity(conversationId: string, payload: any) {
    const conv = this.conversations.get(conversationId);
    if (conv) {
      this.broadcast(conv.relationshipId, {
        type: 'user_activity_state',
        ...payload,
        conversationId
      });
    } else {
      // Fallback: Broadcast to all connections in the conversation room
      console.warn(`[WARN] Broadcasting activity without registration for conversation ${conversationId}`);
      this.broadcastToRoom(conversationId, {
        type: 'user_activity_state',
        ...payload,
        conversationId
      });
    }
  }

  private broadcastToRoom(roomId: string, message: any) {
    const connections = this.rooms.get(roomId) || [];
    connections.forEach(conn => {
      conn.send(JSON.stringify(message));
    });
  }
}

export const messageCore = new MessageCore();
